# 制作時のルールブック

このドキュメントは、2D格闘ゲームプロジェクトにおけるコード生成・修正時の「憲法」です。すべての開発作業はこのルールに従って行われます。

---

## 📋 目次

1. [アーキテクチャの原則](#アーキテクチャの原則)
2. [コードのクリーンネス](#コードのクリーンネス)
3. [アセット管理](#アセット管理)
4. [格闘ゲーム固有の命名規則](#格闘ゲーム固有の命名規則)
5. [ドキュメント](#ドキュメント)
6. [ディレクトリ構造](#ディレクトリ構造)
7. [禁止事項](#禁止事項)

---

## 🏗️ アーキテクチャの原則

### 1. Mainのスリム化

**main.py に直接ロジックを書かない**

- ❌ **禁止**: `main.py` 内での計算ロジック、描画ロジック、複雑な条件分岐
- ✅ **許可**: システムのインスタンス化、最上位の `update()`/`draw()` 呼び出し、ゲームループ

**悪い例**:
```python
# main.py 内で直接ヒット判定を計算
if attacker.rect.colliderect(defender.rect):
    damage = 50
    defender.hp -= damage
    # ... 複雑なロジック
```

**良い例**:
```python
# main.py はシステムを呼び出すだけ
combat_system.check_hits(p1, p2, effects)
```

### 2. カプセル化

**新しい機能は `src/` 配下の適切なフォルダにクラスとして定義する**

- **システム**: `src/systems/` - ゲームロジックを管理（例: `CombatSystem`, `ProjectileSystem`）
- **エンティティ**: `src/entities/` - ゲームオブジェクト（例: `Player`, `Effect`）
- **レンダリング**: `src/rendering/` - 描画ロジック（例: `HUDRenderer`, `StageRenderer`）
- **アセット**: `src/assets/` - リソース管理（例: `AssetManager`, `SoundManager`）
- **UI**: `src/ui/` - ユーザーインターフェース（例: `CommandListMenu`）
- **ユーティリティ**: `src/utils/` - 共通機能（例: `constants.py`, `paths.py`）

**例**: 新しい「コンボシステム」を追加する場合
```python
# src/systems/combo_system.py を作成
class ComboSystem:
    """コンボの検出と管理を行うシステム"""
    
    def __init__(self) -> None:
        self.combo_count = 0
        self.combo_damage = 0
    
    def update(self, attacker: Player, defender: Player) -> None:
        """コンボ状態を更新"""
        # ロジックをここに実装
        pass
```

### 3. オーケストレーション

**main.py は各システムのインスタンス化と、最上位の update/draw 呼び出しのみを行う**

```python
# main.py の役割
def main() -> None:
    # 1. 初期化
    combat_system = CombatSystem(...)
    projectile_system = ProjectileSystem(...)
    shungoku_manager = ShungokuManager(...)
    
    # 2. ゲームループ
    while running:
        # イベント処理
        for event in pygame.event.get():
            ...
        
        # 更新（システムに委譲）
        combat_system.check_hits(...)
        projectile_system.update()
        shungoku_manager.update_dash_sequence(...)
        
        # 描画（レンダラーに委譲）
        stage_renderer.draw_background(...)
        hud_renderer.draw_hp_bars(...)
```

---

## 🧹 コードのクリーンネス

### 1. 500行ルール

**ファイルサイズとメソッドサイズの制限**

- **1ファイル**: 500行を超えそうな場合は分割を検討
- **1メソッド**: 50行を超えそうな場合は分割を検討

**分割の例**:
```python
# 悪い例: 1つの巨大なメソッド（100行）
def update_player(self, player: Player) -> None:
    # 移動処理（20行）
    # ジャンプ処理（15行）
    # 攻撃処理（30行）
    # 特殊技処理（35行）
    pass

# 良い例: 複数の小さなメソッドに分割
def update_player(self, player: Player) -> None:
    self._update_movement(player)
    self._update_jump(player)
    self._update_attack(player)
    self._update_special(player)

def _update_movement(self, player: Player) -> None:
    # 移動処理のみ（20行）
    pass
```

### 2. デッドコード禁止

**リファクタリング後は、古い変数、インポート、未使用のフラグを即座に削除する**

❌ **禁止**:
```python
# 使用されていない変数
old_variable = 100  # もう使っていない

# 使用されていないインポート
import json  # AssetManagerに移動したので不要
from pathlib import Path  # resource_path()で代替

# 使用されていないフラグ
cmdlist_preview_start_ms = 0  # CommandListMenuに移動
```

✅ **正しい対応**:
- リファクタリング完了後、すぐに未使用コードを削除
- `python -m py_compile` でコンパイルチェック
- 削除前にgrepで参照箇所がないか確認

---

## 🎨 アセット管理

### AssetManagerの排他的使用

**画像・音声・フォントのロードに `pygame.image.load` 等を main.py で直接使用することを禁止する**

❌ **禁止**:
```python
# main.py で直接ロード
hit_fx_img = pygame.image.load("assets/images/effect/hit.png").convert_alpha()
stage_bg_img = pygame.image.load("assets/images/stage/01.png").convert_alpha()
```

✅ **正しい方法**:
```python
# AssetManager を経由
assets = AssetManager.load_all_assets(p1, p2)
hit_fx_img = assets.hit_fx_img
stage_bg_img = assets.stage_bg_img
```

**新しいアセットを追加する場合**:

1. `src/assets/asset_manager.py` の `GameAssets` データクラスにフィールドを追加
2. `AssetManager` に読み込みメソッドを追加（例: `_load_new_asset()`）
3. `load_all_assets()` メソッドで読み込みを実行
4. `main.py` で `assets.new_asset` として使用

**例**:
```python
# src/assets/asset_manager.py

@dataclass
class GameAssets:
    # 既存のフィールド
    hit_fx_img: pygame.Surface | None
    
    # 新しいアセットを追加
    ko_effect_img: pygame.Surface | None

class AssetManager:
    @staticmethod
    def _load_ko_effect() -> pygame.Surface | None:
        """KOエフェクト画像を読み込み"""
        ko_path = resource_path("assets/images/effect/ko.png")
        if ko_path.exists():
            return pygame.image.load(str(ko_path)).convert_alpha()
        return None
    
    @staticmethod
    def load_all_assets(p1: Any, p2: Any) -> GameAssets:
        # 既存の読み込み
        hit_fx_img, guard_fx_img = AssetManager._load_hit_guard_fx()
        
        # 新しいアセットを読み込み
        ko_effect_img = AssetManager._load_ko_effect()
        
        return GameAssets(
            hit_fx_img=hit_fx_img,
            ko_effect_img=ko_effect_img,
            # ...
        )
```

---

## 🎮 格闘ゲーム固有の命名規則

### 1. ボタン命名: ギルティギア方式

**P/K/S/HS/D の5ボタン配置を標準とする**

| ボタン | 名称 | キー | 用途 |
|--------|------|------|------|
| **P** | Punch | U | 小技、発生が速い |
| **K** | Kick | J | 中技、リーチが長い |
| **S** | Slash | I | 中技、バランス型 |
| **HS** | Heavy Slash | K | 大技、特殊攻撃 |
| **D** | Dust Attack | O | 対空技、浮かせ技 |

**攻撃IDの命名規則**:
```python
# 正しい命名
"P1_P"   # Player 1 の Punch
"P1_K"   # Player 1 の Kick
"P1_S"   # Player 1 の Slash
"P1_HS"  # Player 1 の Heavy Slash
"P1_D"   # Player 1 の Dust Attack

# 特殊技
"RUSH"           # 突進技
"HADOKEN"        # 波動拳
"SHINKU_HADOKEN" # 真空波動拳
"SHUNGOKUSATSU"  # 瞬獄殺
```

**互換性のための旧SF式命名**:
- キーバインド設定では `P1_LP`, `P1_MP`, `P1_HP` 等の旧SF式も使用可能
- ただし、新しいコードでは **GG式（P/K/S/HS/D）を優先**

### 2. 座標系: 論理ステージ座標

**画面解像度ではなく、`constants.py` で定義された論理ステージ座標を基準に計算する**

```python
# constants.py
STAGE_WIDTH: int = 820   # 論理ステージの幅
STAGE_HEIGHT: int = 540  # 論理ステージの高さ
GROUND_Y: int = 470      # 地面のY座標

SCREEN_WIDTH: int = 1220  # 実際のウィンドウ幅（可変）
SCREEN_HEIGHT: int = 720  # 実際のウィンドウ高さ（可変）
```

❌ **禁止**:
```python
# 画面解像度を直接使用
player.pos_x = SCREEN_WIDTH / 2  # ウィンドウサイズに依存
```

✅ **正しい方法**:
```python
# 論理ステージ座標を使用
player.pos_x = constants.STAGE_WIDTH / 2  # ステージの中心
player.pos_y = constants.GROUND_Y         # 地面の位置
```

**描画時の変換**:
```python
# ステージ（論理解像度）に描画
stage_surface = pygame.Surface((constants.STAGE_WIDTH, constants.STAGE_HEIGHT))
player.draw(stage_surface)

# ウィンドウ（実解像度）に拡大して表示
scaled = pygame.transform.smoothscale(
    stage_surface,
    (constants.SCREEN_WIDTH, constants.SCREEN_HEIGHT)
)
screen.blit(scaled, (0, 0))
```

---

## 📝 ドキュメント

### 新しいクラスを作成した際は、その役割を簡潔に docstring で記述する

**必須要素**:
1. クラスの役割（1行で簡潔に）
2. 主要なメソッドの説明
3. 使用例（必要に応じて）

**例**:
```python
class CombatSystem:
    """
    コンバットシステム。ヒット/ガード処理、ダメージ計算、エフェクト生成を担当。
    
    主要メソッド:
        - apply_hit(): ヒット/ガード判定を実行
        - _apply_damage(): ダメージ処理
        - _apply_guard(): ガード処理
    
    使用例:
        combat_system = CombatSystem(
            spark_frames=assets.spark_frames,
            hit_fx_img=assets.hit_fx_img,
            guard_fx_img=assets.guard_fx_img,
            hit_se=hit_se,
            guard_se=guard_se,
        )
        combat_system.apply_hit(attacker, defender, hit_point, ...)
    """
    
    def apply_hit(
        self,
        attacker: Player,
        defender: Player,
        hit_point: tuple[int, int],
        *,
        game_state: GameState,
        training_p2_all_guard: bool,
        effects: list[Effect],
        p1: Player,
        p2: Player,
    ) -> dict[str, Any]:
        """
        ヒット/ガード処理を実行し、フレームメーターアドバンテージ情報を返す。
        
        Args:
            attacker: 攻撃側プレイヤー
            defender: 防御側プレイヤー
            hit_point: ヒット位置（エフェクト生成用）
            game_state: 現在のゲーム状態
            training_p2_all_guard: トレーニングモードの全ガード設定
            effects: エフェクトリスト（エフェクト追加用）
            p1: プレイヤー1
            p2: プレイヤー2
        
        Returns:
            dict with keys:
            - "frame_meter_adv_value": int | None
            - "frame_meter_adv_frames_left": int
            - "frame_meter_adv_attacker_side": int
        """
        # 実装
        pass
```

---

## 📁 ディレクトリ構造

```
2D格闘ゲーム/
├── main.py                      # ゲームループとシステムのオーケストレーション
├── 制作時のルールブック.md      # このファイル
├── assets/                      # ゲームアセット
│   ├── images/                  # 画像ファイル
│   ├── sounds/                  # 音声ファイル
│   └── fonts/                   # フォントファイル
└── src/                         # ソースコード
    ├── assets/                  # アセット管理
    │   ├── asset_manager.py     # AssetManager クラス
    │   └── sound_manager.py     # SoundManager クラス
    ├── characters/              # キャラクター定義
    │   ├── definition.py        # CharacterDefinition クラス
    │   ├── frame_data.py        # フレームデータ定義
    │   └── ryuko.py             # RYUKO キャラクター
    ├── engine/                  # ゲームエンジン
    │   ├── context.py           # ゲーム状態管理
    │   └── settings.py          # 設定管理
    ├── entities/                # ゲームオブジェクト
    │   ├── player.py            # Player クラス
    │   ├── player_animator.py   # PlayerAnimator クラス
    │   └── effect.py            # エフェクト関連クラス
    ├── rendering/               # 描画ロジック
    │   ├── stage_renderer.py    # StageRenderer クラス
    │   └── hud_renderer.py      # HUDRenderer クラス
    ├── systems/                 # ゲームシステム
    │   ├── combat.py            # CombatSystem クラス
    │   ├── collision.py         # CollisionSystem クラス
    │   ├── projectile_system.py # ProjectileSystem クラス
    │   └── shungoku.py          # ShungokuManager クラス
    ├── ui/                      # ユーザーインターフェース
    │   └── command_list.py      # CommandListMenu クラス
    └── utils/                   # ユーティリティ
        ├── constants.py         # 定数定義
        └── paths.py             # パス管理
```

---

## 🚫 禁止事項

### 絶対にやってはいけないこと

1. **main.py に複雑なロジックを書く**
   - ヒット判定、ダメージ計算、描画ロジックなどは専用クラスに委譲

2. **pygame.image.load を main.py で直接使用**
   - 必ず `AssetManager` を経由

3. **デッドコードを放置**
   - リファクタリング後は即座に削除

4. **500行を超えるファイル・50行を超えるメソッドを放置**
   - 分割を検討

5. **docstring なしでクラスを作成**
   - 必ず役割を記述

6. **画面解像度（SCREEN_WIDTH/HEIGHT）を直接使用**
   - 論理ステージ座標（STAGE_WIDTH/HEIGHT）を使用

7. **旧SF式命名（LP/MP/HP）を新コードで使用**
   - GG式（P/K/S/HS/D）を優先

---

## ✅ チェックリスト

新しいコードを追加する際は、以下を確認してください：

- [ ] main.py に複雑なロジックを書いていないか？
- [ ] 新しい機能を適切な `src/` 配下のフォルダにクラスとして定義したか？
- [ ] AssetManager を経由してアセットを読み込んでいるか？
- [ ] ファイルサイズは500行以内、メソッドサイズは50行以内か？
- [ ] デッドコードを削除したか？
- [ ] docstring を記述したか？
- [ ] GG式のボタン命名（P/K/S/HS/D）を使用しているか？
- [ ] 論理ステージ座標（constants.STAGE_*）を使用しているか？
- [ ] コンパイルチェック（`python -m py_compile`）を実行したか？

---

## 📚 参考資料

### 既存のクラス例

- **システム**: `src/systems/combat.py` - ヒット判定システムの実装例
- **アセット管理**: `src/assets/asset_manager.py` - アセット読み込みの実装例
- **レンダリング**: `src/rendering/hud_renderer.py` - 描画ロジックの実装例
- **エンティティ**: `src/entities/player.py` - ゲームオブジェクトの実装例

### フレームデータの定義

- `src/characters/frame_data.py` - 各技のフレームデータ定義
- `src/characters/ryuko.py` - キャラクター定義

---

**最終更新**: 2026年2月26日
**バージョン**: 1.0.0
